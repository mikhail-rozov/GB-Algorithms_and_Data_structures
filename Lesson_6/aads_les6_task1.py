# Подсчитать, сколько было выделено памяти под переменные в ранее разработанных программах в
# рамках первых трех уроков. Проанализировать результат и определить программы с наиболее
# эффективным использованием памяти.
# Примечание: По аналогии с эмпирической оценкой алгоритмов идеальным решением будет:
# a. выбрать хорошую задачу, которую имеет смысл оценивать по памяти;
# b. написать 3 варианта кода (один у вас уже есть);
# проанализировать 3 варианта и выбрать оптимальный;
#
# c. результаты анализа (количество занятой памяти в вашей среде разработки) вставить в виде
# комментариев в файл с кодом. Не забудьте указать версию и разрядность вашей ОС и интерпретатора Python;
# d. написать общий вывод: какой из трёх вариантов лучше и почему.

# Найти максимальный элемент среди минимальных элементов столбцов матрицы.

from random import randint
import sys


def show_size(x):

    print(f'Объект {x} имеет тип {x.__class__} и занимает в памяти {sys.getsizeof(x)} байтов')

    if hasattr(x, '__iter__'):
        for y in x:
            if not isinstance(y, int):
                print(f'Объект {y} имеет тип {y.__class__} и занимает в памяти {sys.getsizeof(y)} байтов')

    print('*' * 50)


def find_max(n):

    # matrix = [[randint(0, round(1.5 * n)) for _ in range(n)] for _ in range(n)]           # Первый вариант
    # matrix = tuple([randint(0, round(1.5 * n)) for _ in range(n)] for _ in range(n))      # Второй вариант
    matrix = tuple(tuple(randint(0, round(1.5 * n)) for _ in range(n)) for _ in range(n))   # Третий вариант
    cols_min = [line[0] for line in matrix]

    # for line in matrix:
    #     for number in line:
    #         print(f'{number:>5}', end='')
    #     print()

    for line in matrix:
        for i, number in enumerate(line):
            if number < cols_min[i]:
                cols_min[i] = number

    max_cols_min = cols_min[0]

    for number in cols_min:
        if number > max_cols_min:
            max_cols_min = number

    # print(max_cols_min)
    show_size(matrix)
    show_size(cols_min)


print(sys.version)
print(sys.platform)

find_max(5)

""" 
В этой задаче из урока № 3 нужно было найти максимальный элемент среди минимальных элементов столбцов матрицы.
При этом генерировалась квадратная матрица заданного размера как список списков. Далее генерировался список из
минимальных элементов каждого ряда матрицы, и затем находился максимальный элемент этого списка.
1) При размере матрицы 5х5 каждый список занимает в памяти 120 байтов:

3.8.6 (default, Jan 27 2021, 15:42:20) 
[GCC 10.2.0]
linux
Объект [[0, 3, 0, 1, 6], [5, 3, 8, 4, 3], [6, 5, 4, 1, 8], [3, 8, 6, 8, 1], [3, 0, 8, 5, 2]] имеет тип <class 'list'> и 
занимает в памяти 120 байтов
Объект [0, 3, 0, 1, 6] имеет тип <class 'list'> и занимает в памяти 120 байтов
Объект [5, 3, 8, 4, 3] имеет тип <class 'list'> и занимает в памяти 120 байтов
Объект [6, 5, 4, 1, 8] имеет тип <class 'list'> и занимает в памяти 120 байтов
Объект [3, 8, 6, 8, 1] имеет тип <class 'list'> и занимает в памяти 120 байтов
Объект [3, 0, 8, 5, 2] имеет тип <class 'list'> и занимает в памяти 120 байтов
**************************************************
Объект [0, 0, 0, 1, 1] имеет тип <class 'list'> и занимает в памяти 120 байтов

2) Для уменьшения занимаемой памяти можно заменить тип матрицы на кортеж, тогда картина будет следующей:

3.8.6 (default, Jan 27 2021, 15:42:20) 
[GCC 10.2.0]
linux
Объект ([4, 2, 4, 0, 3], [3, 6, 8, 0, 2], [3, 8, 8, 3, 1], [7, 4, 6, 5, 2], [7, 1, 4, 0, 0]) имеет тип <class 'tuple'> 
и занимает в памяти 80 байтов
Объект [4, 2, 4, 0, 3] имеет тип <class 'list'> и занимает в памяти 120 байтов
Объект [3, 6, 8, 0, 2] имеет тип <class 'list'> и занимает в памяти 120 байтов
Объект [3, 8, 8, 3, 1] имеет тип <class 'list'> и занимает в памяти 120 байтов
Объект [7, 4, 6, 5, 2] имеет тип <class 'list'> и занимает в памяти 120 байтов
Объект [7, 1, 4, 0, 0] имеет тип <class 'list'> и занимает в памяти 120 байтов
**************************************************
Объект [3, 1, 3, 0, 0] имеет тип <class 'list'> и занимает в памяти 120 байтов

В данном случае кортеж стал занимать 80 байтов против 120 у списка.

3) Для дальнейшего уменьшения занимаемой памяти можно заменить также списки(ряды) матрицы на кортежи, при этом 
работоспособность программы не пострадает, т.к. программа не изменяет содержимое матрицы.
При этом каждый кортеж занимает в памяти 80 байтов:

3.8.6 (default, Jan 27 2021, 15:42:20) 
[GCC 10.2.0]
linux
Объект ((2, 5, 0, 3, 4), (2, 5, 2, 8, 5), (5, 3, 6, 3, 6), (5, 0, 1, 4, 7), (7, 8, 0, 7, 1)) имеет тип <class 'tuple'> и
занимает в памяти 80 байтов
Объект (2, 5, 0, 3, 4) имеет тип <class 'tuple'> и занимает в памяти 80 байтов
Объект (2, 5, 2, 8, 5) имеет тип <class 'tuple'> и занимает в памяти 80 байтов
Объект (5, 3, 6, 3, 6) имеет тип <class 'tuple'> и занимает в памяти 80 байтов
Объект (5, 0, 1, 4, 7) имеет тип <class 'tuple'> и занимает в памяти 80 байтов
Объект (7, 8, 0, 7, 1) имеет тип <class 'tuple'> и занимает в памяти 80 байтов
**************************************************
Объект [2, 0, 0, 3, 1] имеет тип <class 'list'> и занимает в памяти 120 байтов

Последний объект типа list нельзя заменить на кортеж, т.к. в процессе выполнения программы мы меняем значения его 
элементов.

Из вышеуказанных вариантов можно сделать вывод, что если программа не изменяет содержимое массива после его создания,
то, в разрезе потребления памяти, оптимальнее приводить списки к типу 'кортеж'.
"""
